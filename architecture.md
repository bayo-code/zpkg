# zigpkg architecture

Most of the architecture for this project is modeled after the cargo package manager and crates.io. I don't have any experience with building packages, so I have to learn from somewhere.

It is also possible that some of the assertions here are wrong. Please make the necessary corrections and send a pull request!

There are a few things to note about a package manager:

* **Package**: A package in zigpkg is a set of zig files (or modules), with a version and a set of dependencies. Packages are divided into two categories:
  * Library Packages: contain reusable zig code, and are usually distributed to be used by other applications.
  * Binary Packages: also contain zig code, but the code can be built and installed by `zigpkg` for execution on a user's machine. Binary packages cannot be used as dependencies in other zig code.

* **Registry**: A zigpkg registry is where zig packages are stored. Is also contains an index. An index is a file that stores metadata for all packages in the registry. Things like package names, types, versions, and dependencies are stored in the index.

## Package Specification

The package structure will look something like this:

-- src
    -- main.zig
-- zigpkg.toml
-- zigpkg.lock

This is the typical project structure for a starter `zigpkg`-managed project. Note that there is clearly no `build.zig` file in this structure. I prefer the cargo way of managing projects by just using a configuration file by default, so that is what we're going to start with here. In the future, this architecture will be extended to contain a `build.zig` file for extra flexibility for the project.

The `zigpkg.toml` file is what the package manager will look for in every project root. This file contains the project configuration, and is written in the [TOML](https://toml.io) file format. I think this format is very readable, and that's why I think it will be a perfect fit for zig.

The `zigpkg.lock` file will be automatically generated by `zigpkg`, and will be responsible for **freezing** dependencies. By freezing dependencies after they are fetched, it facilitates reproducible builds, and makes for a more stable and predictable build results.

## ZIGPKG_HOME

The `ZIGPKG_HOME` points to a directory where `zigpkg` stores caches and other relevant files. Inside of this directory, we have the following:

* **pkgs**: Cached packages
* **bin**: Binaries compiled with `zigpkg install` will be stored here.
* **lib**: Shared or static packages compiled with `zigpkg install`.
* **tmp**: Temporary files created by `zigpkg`.

The `ZIG_PKG` environment variable will default to `$HOME/.zigpkg` when it is not explicitly set by the user.

## Features

`zigpkg` will also have the `features` feature of `cargo`, as I think it is a very useful feature to have during development. Features allow you to conditionally enable some code or dependency in a package, and we can exploit zig's comptime feature to facilitate this functionality.

## Package Manifest Parameters

Here is an outline of the possible values that can be specified in the `zigpkg.toml` file:
